<!DOCTYPE html>
<html lang="en">
	<head>

		<title>Editor (alpha 0.1.7)</title>

		<meta charset="utf-8">
		<meta name="generator" content="Three.js Editor">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

		<link rel="stylesheet" href="/css/joystick.css">
		<link rel="stylesheet" href="/css/bootstrap.min.css">
		<link rel="stylesheet" href="/css/bootbox-dialoges.css">
		<link rel="stylesheet" href="/css/jcrop.css">

		<script src="/js/watch.js"></script>
		<script src="/js/Objectid.js"></script>
		<script src="/js/jquery.min.js"></script> 
		<script src="/js/system.min.js"></script>
		<script src="/js/signals.min.js"></script>
		<script src="/js/inflate.min.js"></script>
		<script src="/js/zangodb.min.js"></script>
		<script src="/js/bootstrap.min.js"></script>
		<script src="/js/validator.min.js"></script>
		<script src="/js/hold-event.min.js"></script>
		<script src="/js/jcrop.js"></script>

		<style>

			body {
				margin: 0px;
				font-size: 13px;
				font-family: sans-serif;
				background-repeat: repeat;
				background-image: url("https://i.imgur.com/rnZZU0i.png") !important;
				overflow: hidden;
			}

			#loading-bar {
				width:100%;
				height:100%;
				top:0; left:0;
				position:fixed;
				display:flex;
				align-items:center;
				justify-content:center;
			}

			.middle > * {
				top:0; 
				left:0;
				right:0;
				bottom:0;
				margin:auto;
				position:absolute;
			}

			#joystick1 {
				right: calc(40px + 370px);
			}
			
			#jumpButton {
				right: calc(105px + 370px);
			}

			.btn-matcap,
			.btn-terrain {
				padding:0;
				float:left;
				width:55px;
				height:55px;
				border:1px solid;
				border-radius:4px;
				margin-right:4px;
				margin-bottom:4px;
				display:inline-block;
			}

			.btn-matcap + .btn-matcap,
			.btn-terrain + .btn-terrain {
				margin-right:4px;
			}

		</style>
	</head>

	<body ontouchstart="">

		<script src="/editor/js/TabUI.js"></script>

		<script>
			const debugMode = true;
			const Signal = signals.Signal;
			const RAD2DEG = 57.29577951308232;
			const DEG2RAD = 0.017453292519943295;
			document.body.appendChild( createSidePanel() );
		</script>

		<script src="/editor/js/three.js"></script>
		<script src="/editor/js/MeshWalk.js"></script>
		<script src="/editor/js/UVsDebug.js"></script>
		<script src="/editor/js/FBXLoader.js"></script>
		<script src="/editor/js/VirtualInput.js"></script>
		<script src="/editor/js/KeyboardState.js"></script>
		<script src="/editor/js/EditorControls.js"></script>
		<script src="/editor/js/camera-controls.js"></script>
		<script src="/editor/js/SubdivisionModifier.js"></script>
		<script src="/editor/js/three-pathfinding.umd.js"></script>

		<script src="/threejs/r96/examples/js/loaders/GLTFLoader.js"></script>
		<script src="/threejs/r96/examples/js/exporters/GLTFExporter.js"></script>
		<script src="/threejs/r96/examples/js/exporters/STLExporter.js"></script>
		<script src="/threejs/r96/examples/js/exporters/OBJExporter.js"></script>
		<script src="/threejs/r96/examples/js/exporters/ColladaExporter.js"></script>

	<!-- Water.js -->

		<script src="/editor/js/Ocean_fft.js"></script>
		<script src="/editor/js/MirrorRenderer.js"></script>
		<script src="/editor/js/WaterMaterial.js"></script>

	<!-- Engine.js -->

		<script src="/editor/core/helpers.js"></script>
		<script src="/editor/core/keyboard.js"></script>
		<script src="/editor/core/enviroment.js"></script>
		<script src="/editor/core/localPlayer.js"></script>
		<script src="/editor/core/cameraControls.js"></script>
		<script src="/editor/core/keyboardState.js"></script>
		<script src="/editor/core/keyInputControls.js"></script>
		<script src="/editor/core/joystickControls.js"></script>

	<!-- Editor.js -->

		<script src="/editor/src/EntityManager.js"></script>
		<script src="/editor/src/MaterialManager.js"></script>
		<script src="/editor/src/TexturesManager.js"></script>
		<script src="/editor/src/UndoArray.js"></script>
		<script src="/editor/src/imgru-db.js"></script>
		<script src="/editor/src/editor-meta.js"></script>
		<script src="/editor/src/material-db.js"></script>

		<script src="/editor/src/editor-tab-ui.js"></script>
		<script src="/editor/src/geometry-tab-ui.js"></script>
		<script src="/editor/src/material-tab-ui.js"></script>
		<script src="/editor/src/material-editor-textures-tab-ui.js"></script>
		<script src="/editor/src/images-tab-ui.js"></script>
		<script src="/editor/src/skydome-tab-ui.js"></script>
		<script src="/editor/src/textures-tab-ui.js"></script>

		<script src="/editor/src/watchers-call-ui.js"></script>
		<script src="/editor/src/entities-helpers.js"></script>
		<script src="/editor/src/TextureEditor.js"></script>
		<script src="/editor/src/MaterialEditor.js"></script>
		<script src="/editor/src/Object3DEditor.js"></script>
		<script src="/editor/src/RigidObjects.js"></script>
		<script src="/editor/src/editor-droplists.js"></script>
		<script src="/editor/src/edges-helper.js"></script>
		<script src="/editor/src/octree-helpers.js"></script>
		<script src="/editor/src/geometry-buttons.js"></script>
		<script src="/editor/src/geometry-inputs.js"></script>
		<script src="/editor/src/editor-buttons.js"></script>
		<script src="/editor/src/rigid-objects-buttons.js"></script>
		<script src="/editor/src/editor-key-inputs.js"></script>
		<script src="/editor/src/editor-mouse-inputs.js"></script>
		<script src="/editor/src/editor-manager.js"></script>
		<script src="/editor/src/editor-systems.js"></script>
		<script src="/editor/src/material-droplists.js"></script>
		<script src="/editor/src/material-manager.js"></script>
		<script src="/editor/src/material-buttons.js"></script>
		<script src="/editor/src/material-key-inputs.js"></script>
		<script src="/editor/src/material-mouse-inputs.js"></script>
		<script src="/editor/src/texture-droplists.js"></script>
		<script src="/editor/src/texture-manager.js"></script>
		<script src="/editor/src/texture-buttons.js"></script>
		<script src="/editor/src/texture-key-inputs.js"></script>
		<script src="/editor/src/texture-mouse-inputs.js"></script>
		<script src="/editor/src/texture-viewer.js"></script>
		<script src="/editor/src/editor-center-helper.js"></script>
		<script src="/editor/src/Water.js"></script>
		<script src="/editor/src/Skydome.js"></script>
		<script src="/editor/src/skydome-droplist.js"></script>
		<script src="/editor/src/background-droplist.js"></script>
		<script src="/editor/src/skydome-buttons.js"></script>
		<script src="/editor/src/images-inputs.js"></script>
		<script src="/editor/src/images-uploads.js"></script>

		<script src="/editor/src/create-new-material-tab-ui.js"></script>
		<script src="/editor/src/create-new-material-viewer.js"></script>
		<script src="/editor/src/create-new-material-buttons.js"></script>

		<script src="/editor/src/material-library-tab-ui.js"></script>
		<script src="/editor/src/material-library-upload-button.js"></script>
		<script src="/editor/src/material-library-update-button.js"></script>
		<script src="/editor/src/material-library-inputs.js"></script>

		<script>

		//	MaterialEditorViewer.js

			const materialEditorViewer = {

				canvas: TabUI.MaterialEditorTextures.tab.querySelector("canvas#material-editor-textures-viewer"),

			};

			(function( viewer, materialEditor ){

			//	Viewer scene.

				viewer.scene = (function(){
					var scene = new THREE.Scene();
					scene.name = "viewer scene";
					return scene;
				})();

			//	Viewer camera.

				viewer.camera = (function(){
					var camera  = new THREE.OrthographicCamera( -128,128,128,-128, 1, 1000 );
					camera.name = "viewer camera"; camera.position.y = 10; camera.lookAt( 0,0,0 );
					viewer.scene.add( camera ); return camera;
				})();

			//	Viewer light.

				viewer.light = (function(){
					var light = new THREE.DirectionalLight( 0xffffff, 1 );
					light.name = "viewer light"; light.position.set( -1, 10, 1 );
					viewer.scene.add( light ); return light;
				})();

			//	Viewer grid.

				viewer.grid = (function(){
					var helper = new THREE.GridHelper( 250, 10, 0x444444, 0x444444 );
					helper.name = "viewer grid";  helper.visible = true; 
					helper.position.y = 0.01; viewer.scene.add( helper ); return helper;
				})();

			//  Viewer Renderer.

				viewer.renderer = new THREE.WebGLRenderer({
					alpha: true,  // for transparent rendering set alpha:true, important!
					canvas: viewer.canvas, antialias: true, preserveDrawingBuffer: true,
				});

				viewer.renderer.gammaInput = true;
				viewer.renderer.gammaOutput = true;
				viewer.renderer.shadowMap.enabled = true;
				viewer.renderer.setClearAlpha( 0 ); // for transparent rendering set clear alpha: 0.
				viewer.renderer.setClearColor( 0x000000, 0 ); // for transparent rendering set clear alpha: 0.
				viewer.renderer.setPixelRatio( window.devicePixelRatio );
				viewer.renderer.setSize( viewer.canvas.width, viewer.canvas.height );
				viewer.renderer.domElement.style.background = "none";  // transparent rendering. important!
				viewer.render = function(){ viewer.renderer.render( viewer.scene, viewer.camera ); };

				(function render(){ requestAnimationFrame( render ); viewer.render(); })(); // debug!

			//	Viewer material.

				viewer.material = materialEditor;

				viewer.mesh = (function( material ){
					var geometry = new THREE.PlaneGeometry(252,252,1,1);
				//	geometry.rotateX(-Math.PI/2);
					var mesh = new THREE.Mesh( geometry, material ); 
					mesh.name = "viewer mesh"; 
					mesh.rotation.x = -Math.PI/2; 
					viewer.scene.add( mesh ); 
					return mesh;
				})( materialEditor );

			//	Viewer center helper.

				viewer.center = (function(){

					var object = new THREE.Object3D(); // helper.
					var material = new THREE.LineBasicMaterial( { color: 0x000000 } );

				//	cycle.

					(function(){
						var cycleGeometry = new THREE.CircleGeometry(5,32).rotateX(-Math.PI/2);
						var geometry = new THREE.EdgesGeometry( cycleGeometry );
						var segments = new THREE.LineSegments( geometry, material );
						object.add( segments );
					})();

				//	haircross.

					(function(){
						var geometry = new THREE.Geometry();
						geometry.vertices.push(
							new THREE.Vector3( -10, 0, 0 ),
							new THREE.Vector3(  10, 0, 0 )
						);
						var segments = new THREE.LineSegments( geometry, material );
						object.add( segments );
					})();

					(function(){
						var geometry = new THREE.Geometry();
						geometry.vertices.push(
							new THREE.Vector3( 0, 0, -10 ),
							new THREE.Vector3( 0, 0,  10 )
						);
						var segments = new THREE.LineSegments( geometry, material );
						object.add( segments );
					})();

					return object;
				})();

				viewer.scene.add( viewer.center );
				viewer.center.position.set(-125,0.1,125); // (x,y) = (0,0) important!
			//	debugMode && console.log( viewer.center );

			//	dispose.

				viewer.dispose = function(){

					(function( material ){
					//	dispose textures.
						material && material.map && material.map.dispose && material.map.dispose();
						material && material.bumpMap && material.bumpMap.dispose && material.bumpMap.dispose();
						material && material.alphaMap && material.alphaMap.dispose && material.alphaMap.dispose();
						material && material.normalMap && material.normalMap.dispose && material.normalMap.dispose();
						material && material.emissiveMap && material.emissiveMap.dispose && material.emissiveMap.dispose();
						material && material.roughnessMap && material.roughnessMap.dispose && material.roughnessMap.dispose();
						material && material.metalnessMap && material.metalnessMap.dispose && material.metalnessMap.dispose();
						material && material.displacementMap && material.displacementMap.dispose && material.displacementMap.dispose();
						material && material.lightMap && material.lightMap.dispose && material.lightMap.dispose();
						material && material.envMap && material.envMap.dispose && material.envMap.dispose();
						material && material.aoMap && material.aoMap.dispose && material.aoMap.dispose();
					})( viewer.material );

					(function(){
					//	remove textures.
						viewer.material.map = null;
						viewer.material.bumpMap = null;
						viewer.material.alphaMap = null;
						viewer.material.normalMap = null;
						viewer.material.emissiveMap = null;
						viewer.material.roughnessMap = null;
						viewer.material.metalnessMap = null;
						viewer.material.displacementMap = null;
						viewer.material.lightMap = null;
						viewer.material.envMap = null;
						viewer.material.aoMap = null;
					})();

				//	update material.
					viewer.material.needsUpdate = true; // important!
				}

			//	reset.

				viewer.reset = function(){
					viewer.dispose();
					viewer.material.color.setHex(0xffffff);
					viewer.center.position.set(-125, 0.1, 125); // reset!
				}


			})( materialEditorViewer, materialEditor ); // viewer, material.

		</script>

		<script>

		//	material-editor-viewer-toggle-grid.js

			(function(viewer,grid_button){

				watch( grid_button, "onclick", function(prop, event, value){ debugMode && console.log({item:grid_button,event:event,value:value}); });  // debug!

				watch( grid_button, "onclick", function(prop, event, value){ viewer.grid.visible = !viewer.grid.visible; });
				grid_button.addEventListener( "click", function(){ callWatchers( this, "onclick", "click", viewer.grid.visible ); });

			})( materialEditorViewer, TabUI.MaterialEditorTextures.tab.querySelector("div#material-editor-textures-viewer-grid") ); // viewer, grid_button.

		//	material-editor-textures-needs-update.js

			(function(editor,needs_update){

				watch( needs_update, "onclick", function(prop, event, value){ debugMode && console.log({item:needs_update,event:event,value:value}); });  // debug!

				var keys = "map,aoMap,envMap,lightMap,bumpMap,alphaMap,normalMap,specularMap,";
					keys += "gradientMap,emissiveMap,metalnessMap,roughnessMap,displacementMap";

				const maps = keys.split(",");

				watch( needs_update, "onclick", function(prop, event, value){
					maps.forEach(function(name){ 
						if ( !editor[name] ) return; 
						editor[name].needsUpdate = true; // or value;
					}); editor.needsUpdate = true; 
				}); 

				needs_update.addEventListener( "click", function(){ callWatchers( this, "onclick", "click", true ); });

			})( materialEditor, TabUI.MaterialEditorTextures.tab.querySelector("div#material-editor-textures-needs-update") ); // editor, needs_update.

		//	material-editor-textures-remove-map.js

			(function(editor,remove_button,map_droplist){

				watch( remove_button, "onclick", function(prop, event, value){ debugMode && console.log({item:remove_button,event:event,value:value}); });  // debug!

				watch( remove_button, "onclick", function(prop, event, key){ 
					if ( !key ) return; if ( !editor[key] ) return; editor[key] = null; editor.needsUpdate = true;
					callWatchers( map_droplist, "onchange", "change", map_droplist.value = "" ); // reset droplist.
				}); 

				remove_button.addEventListener( "click", function(){ callWatchers( this, "onclick", "click", map_droplist.value ); });

			})( 
				materialEditor, // editor,
				TabUI.MaterialEditorTextures.tab.querySelector("div#material-editor-textures-remove-map"),  // remove_button,
				TabUI.MaterialEditorTextures.tab.querySelector("select#material-editor-textures-map-droplist") // map_droplist.
			);

		//	material-editor-textures-apply-textures.js

			(function(editor,apply_button,map_droplist){

				watch( apply_button, "onclick", function(prop, event, value){ debugMode && console.log({item:apply_button,event:event,object:value}); });  // debug!

			//	watch( apply_button, "onclick", function(prop, event, object){ 
			//	});

				watch( apply_button, "onclick", function(prop, event, object){ 
					if ( !object ) return; 
				//	if ( object ) object.material.copy( editor ); return; // fast and dirty!
					var maps  = "map,aoMap,envMap,lightMap,bumpMap,alphaMap,normalMap,specularMap,";
						maps += "gradientMap,emissiveMap,metalnessMap,roughnessMap,displacementMap";
					maps.split(",").forEach(function(name){ 
						if ( editor[name] !== undefined ) object.material[name] = editor[name]; 
					});
				}); 

				apply_button.addEventListener( "click", function(){ callWatchers( this, "onclick", "click", getObjectByEntityId() ); });

			//	function get_textures(material){
			//		var maps  = "map,aoMap,envMap,lightMap,bumpMap,alphaMap,normalMap,specularMap,";
			//			maps += "gradientMap,emissiveMap,metalnessMap,roughnessMap,displacementMap";
			//		return maps.split(",").map(function(name){ return material[name]; }).filter(Boolean); 
			//	}

			})( 
				materialEditor, // editor,
				TabUI.MaterialEditorTextures.tab.querySelector("div#material-editor-textures-apply-button"),  // apply_button,
				TabUI.MaterialEditorTextures.tab.querySelector("select#material-editor-textures-map-droplist") // map_droplist.
			);

		//	material-editor-textures-replace-image.js

			(function(editor,input,button,map_droplist){

				watch( button, "onclick", function(prop, event){ debugMode && console.log({item:button,event:event}); }); // get_textures();

				function get_textures(material){
					var maps  = "map,aoMap,envMap,lightMap,bumpMap,alphaMap,normalMap,specularMap,";
						maps += "gradientMap,emissiveMap,metalnessMap,roughnessMap,displacementMap";
					var textures = maps.split(",").map(function(name){ return material[name]; }).filter(Boolean); 
					if ( textures.length ) return textures[0]; return;
				}

				function copy_values( source, texture ){
					if ( !texture ) texture = new THREE.Texture(); if ( !source ) return texture; 
					var vectors = "offset,repeat,center"; 
					var keys = "flipY,format,rotation,mapping,minFilter,magFilter,anisotropy,wrapS,wrapT";
					keys.split(",").forEach(function(key){ texture[key] = source[key]; }); 
					vectors.split(",").forEach(function(vec){ texture[vec].copy(source[vec]); }); return texture;
				}

				watch( input, "onchange", function(prop, event, key){
					debugMode && console.log({item:button,event:event,value:key});

					if ( input.files.length === 0 ) return;

					var file = input.files[0];

					var img = new Image();
					img.addEventListener("load", function(){

					//	make power of two.
						var canvas = document.createElement("canvas");
						canvas.width = THREE.Math.floorPowerOfTwo( img.width );
						canvas.height = THREE.Math.floorPowerOfTwo( img.height );
						var context = canvas.getContext( "2d" );
						context.drawImage( img, 0, 0, canvas.width, canvas.height );
						debugMode && console.log( canvas );

					//	replace image.
						var texture; if ( editor[ key ] ) texture = editor[ key ];
						else texture = editor[ key ] = copy_values( get_textures(editor), new THREE.Texture() );
					//	var texture = editor[ key ]; if ( !editor[key] ) texture = editor[ key ] = new THREE.Texture(); 
						texture.image = canvas; texture.sourceFile = file.name; 
						texture.name = file.name.replace(".png","").replace(".jpg","").replace(/_/g," ");
						if ( texture.image !== undefined ) texture.needsUpdate = editor.needsUpdate = true; // important!
						debugMode && console.log( texture );

					//	reset map droplist.
						callWatchers( map_droplist, "onchange", "change", map_droplist.value = "" );
					});

					var reader = new FileReader();
					reader.addEventListener("load", function() {
						img.name = file.name;
						img.src = reader.result;
					});

					reader.readAsDataURL(file);
				});

				button.addEventListener( "click", function(){ 
					if ( !map_droplist.value ) return; input.value = "";
					callWatchers( this, "onclick", "click", input.click() );
				});

				input.addEventListener( "change", function(){
					callWatchers( input, "onchange", "change", map_droplist.value );
				});

			})( 
				materialEditor, // editor,
				TabUI.MaterialEditorTextures.tab.querySelector("input#material-editor-textures-file-input"),   // input,
				TabUI.MaterialEditorTextures.tab.querySelector("div#material-editor-textures-replace-image"),  // button,
				TabUI.MaterialEditorTextures.tab.querySelector("select#material-editor-textures-map-droplist") // map_droplist.
			);

		</script>

		<script>

		//	material-editor-textures-value-mouse-input.js

			(function( editor,entity_droplist,text_input,value_input,increase,decrease,key_droplist,map_droplist ){

				const RAD2DEG = 57.29577951308232; const DEG2RAD = 0.017453292519943295;

				var key, textures = []; 
				const maps = (function(){
					var keys  = "map,aoMap,envMap,lightMap,bumpMap,alphaMap,normalMap,specularMap,";
					    keys += "gradientMap,emissiveMap,metalnessMap,roughnessMap,displacementMap";
					return keys.split(",")
				})(); 

				watch( key_droplist, "onchange", function(prop, event, value){ key = value; }); // important!
				var interval; window.addEventListener( "mouseup", function (){ clearTimeout( interval ); }); // important!

				function get_textures(){
					textures.length = 0; maps.forEach(function(name){ if ( editor[name] ) textures.push( editor[name] ); });
				}

				watch( map_droplist,    "onchange", function(prop, event, value){ get_textures(); });
				watch( key_droplist,    "onchange", function(prop, event, value){ get_textures(); });
				watch( entity_droplist, "onchange", function(prop, event, value){ get_textures(); });

				function onMouseClickInputValue(button){ 

					function updateFloatRotationValue(button, min, max, step, value){
						var step = 0.1 * Math.PI/180; // 0.1 deg.
						var min = -Math.PI, max = Math.PI;
						if ( isNaN(value) ) return value_input.value = ""; // avoid to pass NaN editor[key] value.
						if ( button === increase ) value = THREE.Math.clamp( value+step, min, max ); // rad.
						if ( button === decrease ) value = THREE.Math.clamp( value-step, min, max ); // rad.
						textures.forEach(function(texture, i){ textures[i][key] = value; })
						value_input.value = (RAD2DEG*value).toFixed(1);
					}

					function updateFloatNumberValue(button, min, max, step, value){
						if ( isNaN(value) ) return value_input.value = ""; // avoid to pass NaN editor[key] value.
						if ( button === increase ) value = THREE.Math.clamp( value+step, min, max );
						if ( button === decrease ) value = THREE.Math.clamp( value-step, min, max );
						textures.forEach(function(texture, i){ textures[i][key] = value; })
						value_input.value = value.toFixed(3);
					}

					function updateConstantNumberValue(button, values, value){
						var min = 0, max = values.length;
						var index = values.findIndex(function( item ){ return item === value; });
						if ( button === increase ) value = values[ ( ++index % max + max ) % max ]; // mod();
						if ( button === decrease ) value = values[ ( --index % max + max ) % max ]; // mod();
						textures.forEach(function(texture, i){ textures[i][key] = value; })
						value_input.value = value.toFixed(0);
					}

					function update_textures_value( button, texture ){

						switch( key ){

						//	string types:

							case "uuid": 
								return (function( value ){
									if (!map_droplist.value) return;
									var name = map_droplist.value;
									if ( texture.id === editor[name].id ) 
										text_input.value = texture[ key ] = value;
								})( THREE.Math.generateUUID() );
							break;

						//	boolean types:

							case "flipY":
							case "premultiplyAlpha":
							case "matrixAutoUpdate":
							case "generateMipmaps":
								return (function( value ){
									textures.forEach(function(texture, i){ 
										textures[i][key] = value; 
										textures[i].needs_update = true;
									}); value_input.value = value;
								})( !texture[ key ] );
							break;

						//	number types:

							case "wrapS":
							case "wrapT":
								updateConstantNumberValue(button, [
									THREE.RepeatWrapping,THREE.ClampToEdgeWrapping,THREE.MirroredRepeatWrapping 
								], texture[key]); 
								return textures.forEach(function(texture, i){ textures[i].needsUpdate = true; });  // important!
							break;

							case "type":
								updateConstantNumberValue(button, [], texture[key]);
								return textures.forEach(function(texture, i){ textures[i].needsUpdate = true; });  // important!
							break;

							case "format":
								updateConstantNumberValue(button, [
									THREE.AlphaFormat,THREE.RGBFormat,THREE.RGBAFormat,
									THREE.LuminanceFormat,THREE.LuminanceAlphaFormat
								], texture[key]);
								return textures.forEach(function(texture, i){ textures[i].needsUpdate = true; });  // important!
							break;

							case "mapping":
								updateConstantNumberValue(button, [
									THREE.UVMapping,THREE.CubeReflectionMapping,THREE.CubeRefractionMapping,
									THREE.EquirectangularReflectionMapping,THREE.EquirectangularRefractionMapping,
									THREE.SphericalReflectionMapping,THREE.CubeUVReflectionMapping,THREE.CubeUVRefractionMapping
								], texture[key]);
								return textures.forEach(function(texture, i){ textures[i].needsUpdate = true; });  // important!
							break;

							case "encoding":
								updateConstantNumberValue(button, [
									THREE.LinearEncoding,THREE.sRGBEncoding,THREE.GammaEncoding,THREE.RGBEEncoding,
									THREE.LogLuvEncoding,THREE.RGBM7Encoding,THREE.RGBM16Encoding,THREE.RGBDEncoding,
									THREE.BasicDepthPacking,THREE.RGBADepthPacking 
								], texture[key]);
								return textures.forEach(function(texture, i){ textures[i].needsUpdate = true; });  // important!
							break;

							case "magFilter":
								updateConstantNumberValue(button, [THREE.NearestFilter,THREE.LinearFilter], texture[key]);
								return textures.forEach(function(texture, i){ textures[i].needsUpdate = true; });  // important!
							break;

							case "minFilter":
								updateConstantNumberValue(button, [
									THREE.NearestFilter,THREE.NearestMipMapNearestFilter,
									THREE.NearestMipMapLinearFilter,THREE.LinearFilter,
									THREE.LinearMipMapNearestFilter,THREE.LinearMipMapLinearFilter 
								], texture[key]);
								return textures.forEach(function(texture, i){ textures[i].needsUpdate = true; });  // important!
							break;

							case "anisotropy":
								return updateFloatNumberValue(button, -1, 1, 1/100, texture[key]);
							break;

							case "rotation":
								return updateFloatRotationValue(button, null, null, null, texture[key]);
							break;
						}
					}

					button.addEventListener( "mousedown", function(){
						clearTimeout( interval ); // important!

						var texture; var name = map_droplist.value;
						if ( name && editor[ name ] ) texture = editor[ name ];
						else if ( textures.length ) texture = textures[0]; 
						else return;

						interval = setTimeout( function update_textures(button){

							switch( key ){
								case "anisotropy":
									interval = setTimeout( update_textures, 20, button );
									return updateFloatNumberValue( button,-1, 1, 1/100, texture[key] );
								break;
								case "rotation":
									interval = setTimeout( update_textures, 20, button );
									return updateFloatRotationValue( button, null, null, null, texture[key]);
								break;
							}

						}, 500, this);
					});

					button.addEventListener( "click", function(){
						clearTimeout( interval );

						var texture; var name = map_droplist.value;
						if ( name && editor[ name ] ) texture = editor[ name ];
						else if ( textures.length ) texture = textures[0];
						else return;

						update_textures_value( this, texture );
					});

				}

				onMouseClickInputValue(increase);
				onMouseClickInputValue(decrease);

			})(
				materialEditor, TabUI.Material.tab.querySelector("select#material-entities-droplist"), // (material) entity_droplist.
				TabUI.MaterialEditorTextures.tab.querySelector("input#material-editor-textures-text-input"),    // text_input,
				TabUI.MaterialEditorTextures.tab.querySelector("input#material-editor-textures-value-input"),   // value_input,
				TabUI.MaterialEditorTextures.tab.querySelector("li#material-editor-textures-value-increase"),   // increase,
				TabUI.MaterialEditorTextures.tab.querySelector("li#material-editor-textures-value-decrease"),   // decrease,
				TabUI.MaterialEditorTextures.tab.querySelector("select#material-editor-textures-key-droplist"), // key_droplist
				TabUI.MaterialEditorTextures.tab.querySelector("select#material-editor-textures-map-droplist")  // map_droplist.
			);

		//	material-editor-textures-vector-mouse-input.js

			(function( editor,viewer,entity_droplist,vector_x,vector_y,increase_x,increase_y,decrease_x,decrease_y,vector_droplist,map_droplist ){

				var key, textures = []; 
				const maps = (function(){
					var keys  = "map,aoMap,envMap,lightMap,bumpMap,alphaMap,normalMap,specularMap,";
					    keys += "gradientMap,emissiveMap,metalnessMap,roughnessMap,displacementMap";
					return keys.split(",")
				})(); 

				watch( vector_droplist, "onchange", function(prop, event, value){ key = value; }); // important!
				var interval; window.addEventListener( "mouseup", function (){ clearTimeout( interval ); }); // important!

				function get_textures(){
					textures.length = 0; maps.forEach(function(name){ if ( editor[name] ) textures.push( editor[name] ); }); // debugMode && console.log( textures );
				}

				watch( map_droplist,    "onchange", function(prop, event, value){ get_textures(); });
				watch( vector_droplist, "onchange", function(prop, event, value){ get_textures(); });
				watch( entity_droplist, "onchange", function(prop, event, value){ get_textures(); });

				function onMouseClickInputValue(button){ 

					function updateVectorValues( button, min,max,step ){
						if ( textures.length ) { 
							var texture = textures[0];
							if ( button === increase_x ) texture[key].x = round( THREE.Math.clamp( texture[key].x+step, min, max ), 6);
							if ( button === decrease_x ) texture[key].x = round( THREE.Math.clamp( texture[key].x-step, min, max ), 6);
							if ( button === increase_y ) texture[key].y = round( THREE.Math.clamp( texture[key].y+step, min, max ), 6);
							if ( button === decrease_y ) texture[key].y = round( THREE.Math.clamp( texture[key].y-step, min, max ), 6);
							for ( var i = 1; i < textures.length; i++ ) { textures[i][key].copy( texture[key] ); }
							[ vector_x.value, vector_y.value ] = [ texture[key].x.toFixed(3),  texture[key].y.toFixed(3) ];

							(function( key ){ // Update viewer center helper.
								if ( vector_droplist.value !== key ) return;
								try {	viewer.center.position.x = -125 + (250 * texture.center.x); // update center position (x).
										viewer.center.position.z =  125 - (250 * texture.center.y); // update center position (z).
								} catch(err){ debugMode && console.error(err); }
							})( "center" );

						}
					}

					button.addEventListener( "mousedown", function(){
						clearTimeout( interval ); // important!
						interval = setTimeout( function update_textures( button ){
							switch ( key ){
								case "center":
									interval = setTimeout( update_textures, 20, button );
									return updateVectorValues( button, 0, 1, 1/100 );
								break;
								case "offset":
									interval = setTimeout( update_textures, 10, button );
									return updateVectorValues( button,-100,100,1/1000 );
								break;
								case "repeat":
									interval = setTimeout( update_textures, 10, button );
									return updateVectorValues( button, -100,100,1/1000 );
								break;
							}
						}, 500, this);
					});

					button.addEventListener( "click", function(){
						clearTimeout( interval );
						switch ( key ){
							case "center":
								return updateVectorValues( button, 0, 1, 1/100 );
							break;
							case "offset":
								return updateVectorValues( button, -100,100,1/1000 );
							break;
							case "repeat":
								return updateVectorValues( button, -100,100,1/1000 );
							break;
						}
					});

				}

				onMouseClickInputValue(increase_x); onMouseClickInputValue(increase_y);
				onMouseClickInputValue(decrease_x); onMouseClickInputValue(decrease_y);

			})(
				materialEditor, materialEditorViewer, // editor, viewer,
				TabUI.Material.tab.querySelector("select#material-entities-droplist"), // (material) entity_droplist.
				TabUI.MaterialEditorTextures.tab.querySelector("input#material-editor-textures-vector-x-input"),   // vector_x,
				TabUI.MaterialEditorTextures.tab.querySelector("input#material-editor-textures-vector-y-input"),   // vector_y,
				TabUI.MaterialEditorTextures.tab.querySelector("li#material-editor-textures-vector-x-increase"),   // increase_x,
				TabUI.MaterialEditorTextures.tab.querySelector("li#material-editor-textures-vector-y-increase"),   // increase_y,
				TabUI.MaterialEditorTextures.tab.querySelector("li#material-editor-textures-vector-x-decrease"),   // decrease_x,
				TabUI.MaterialEditorTextures.tab.querySelector("li#material-editor-textures-vector-y-decrease"),   // decrease_y,
				TabUI.MaterialEditorTextures.tab.querySelector("select#material-editor-textures-vector-droplist"), // vector_droplist
				TabUI.MaterialEditorTextures.tab.querySelector("select#material-editor-textures-map-droplist")     // map_droplist.
			);

		</script>

		<script>

		//	material-editor-textures-key-inputs.js

			(function(editor,viewer,text_input,value_input,vector_x,vector_y,key_droplist,vector_droplist,map_droplist){

				const RAD2DEG = 57.29577951308232; const DEG2RAD = 0.017453292519943295;

				function get_textures(material){
					var maps  = "map,aoMap,envMap,lightMap,bumpMap,alphaMap,normalMap,specularMap,";
						maps += "gradientMap,emissiveMap,metalnessMap,roughnessMap,displacementMap";
					return maps.split(",").map(function(name){ return material[name]; }).filter(Boolean); 
				}

				watch( vector_x, "onchange", function(property, event, value){

					var key = vector_droplist.value;

					if ( !value ) return vector_x.value = "";
					if ( !get_textures(editor).length ) return vector_x.value = "";

					switch( key ){

						case "offset":
						case "repeat":

							return (function(value){
								if ( isNaN(value) ) return vector_x.value = get_textures(editor)[0][key].x.toFixed(3);
								get_textures(editor).forEach(function(texture){ texture[key].x = value; });
								return vector_x.value = value.toFixed(3);
							})( THREE.Math.clamp( Number(value), -100, 100 ) );

						break;

						case "center":
							return (function(value){
								if ( isNaN(value) ) return vector_x.value = get_textures(editor)[0][key].x.toFixed(3);
								get_textures(editor).forEach(function(texture){ texture[key].x = value; });
							//	update viewer center position (x).
								try { viewer.center.position.x = -125 + (250 * value); } catch(err){ debugMode && console.error(err); }
								return vector_x.value = value.toFixed(3);
							})( Number(THREE.Math.clamp( Number(value), 0, 1 )) );
						break;
					}

				});

				watch( vector_y, "onchange", function(property, event, value){

					var key = vector_droplist.value;

					if ( !value ) return vector_y.value = "";
					if ( !get_textures(editor).length ) return vector_y.value = "";

					switch( key ){

						case "offset":
						case "repeat":

							return (function(value){
								if ( isNaN(value) ) return vector_y.value = get_textures(editor)[0][key].y.toFixed(3);
								get_textures(editor).forEach(function(texture){ texture[key].y = value; });
								return vector_y.value = value.toFixed(3);
							})( THREE.Math.clamp( Number(value), -100, 100 ) );

						break;

						case "center":
							return (function(value){
								if ( isNaN(value) ) return vector_y.value = get_textures(editor)[0][key].y.toFixed(3);
								get_textures(editor).forEach(function(texture){ texture[key].y = value; });
							//	update center position (z).
								try { viewer.center.position.z =  125 - (250 * value); } catch(err){ debugMode && console.error(err); }
								return vector_y.value = value.toFixed(3);
							})( Number(THREE.Math.clamp( Number(value), 0, 1 )) );
						break;
					}

				});

			//	text input.

				watch( text_input, "onchange", function(property, event, value){

					var key = key_droplist.value;

					if ( !value ) return text_input.value = "";
					var name = map_droplist.value; if ( !name ) return text_input.value = "";
					var texture = editor[ name ]; if ( !texture ) return text_input.value = "";

					switch ( key ){
						case "name":
						case "uuid":
							return text_input.value = texture[key];
						break;
					}

					value_input.value = "";
				});

			//	value input.

				watch( value_input, "onchange", function( prop, event, value ){

					var key = key_droplist.value;

					if ( !value ) return value_input.value = "";
					if ( !get_textures(editor).length ) return value_input.value = "";

					switch( key ){

					//	boolean types:
						case "flipY":
						case "premultiplyAlpha":
						case "matrixAutoUpdate":
						case "generateMipmaps":
							return (function(value){
								if ( value === "0") value = false;
								else if ( value === "1") value = true;
								else if ( value.toLowerCase() === "true") value = true;
								else if ( value.toLowerCase() === "false") value = false;
								get_textures(editor).forEach(function(texture){ texture[key] = value; });
								return value_input.value = value;
							})( value );
						break;

					//	number types:
						case "type":
						case "wrapS":
						case "wrapT":
						case "format":
						case "mapping":
						case "minFilter":
						case "magFilter":

							return (function(value){
							//	TODO: check value.
							//	value_input.value = value.toFixed(0);
								return value_input.value = get_textures(editor)[0][key].toFixed(0); // debug!
							})( value );

						break;
						case "anisotropy":

							return (function(value){
								if ( isNaN(value) ) return value_input.value = 
									get_textures(editor)[0][key].toFixed(2);
								get_textures(editor).forEach(function(texture){ texture[key] = value; });
								return value_input.value = value.toFixed(2);
							})( Number(value) );

						break;
						case "rotation":

							return (function(value){
								if ( isNaN(value) ) return value_input.value = 
									(RAD2DEG*get_textures(editor)[0][key]).toFixed(1);
								get_textures(editor).forEach(function(texture){ texture[key] = value; });
								return value_input.value = (RAD2DEG*value).toFixed(1);
							})( DEG2RAD*Number(value) );

						break;
					}
				});

				vector_x.addEventListener( "change", function(){ this.blur(); callWatchers(this, "onchange", "change", this.value); });
				vector_y.addEventListener( "change", function(){ this.blur(); callWatchers(this, "onchange", "change", this.value); });
				text_input.addEventListener( "change", function(){ this.blur(); callWatchers(this, "onchange", "change", this.value); });
				value_input.addEventListener( "change", function(){ this.blur(); callWatchers(this, "onchange", "change", this.value); });

			})(
				materialEditor, materialEditorViewer, // editor, viewer,
				TabUI.MaterialEditorTextures.tab.querySelector("input#material-editor-textures-text-input"),       // text_input,
				TabUI.MaterialEditorTextures.tab.querySelector("input#material-editor-textures-value-input"),      // value_input,
				TabUI.MaterialEditorTextures.tab.querySelector("input#material-editor-textures-vector-x-input"),   // vector_x,
				TabUI.MaterialEditorTextures.tab.querySelector("input#material-editor-textures-vector-y-input"),   // vector_y,
				TabUI.MaterialEditorTextures.tab.querySelector("select#material-editor-textures-key-droplist"),    // key_droplist.
				TabUI.MaterialEditorTextures.tab.querySelector("select#material-editor-textures-vector-droplist"), // vector_droplist.
				TabUI.MaterialEditorTextures.tab.querySelector("select#material-editor-textures-map-droplist")     // map_droplist.
			);

		</script>

		<script>

		//	material-editor-textures-key-droplist.js

			(function(editor,text_input,value_input,key_droplist,map_droplist){

				const RAD2DEG = 57.29577951308232; const DEG2RAD = 0.017453292519943295;

				function get_textures(material){
					var textures = []; // textures.length = 0;
					var keys  = "map,aoMap,envMap,lightMap,bumpMap,alphaMap,normalMap,specularMap,";
						keys += "gradientMap,emissiveMap,metalnessMap,roughnessMap,displacementMap";
					keys.split(",").forEach(function(name){ if ( material[name] ) textures.push( material[name] ); }); 
					if ( textures.length ) return textures[0];
				}

				watch( key_droplist, "onchange", function(prop, event, key){ 
					
					var texture, name = map_droplist.value;
					if ( name ) texture = editor[ name ];
					if ( !texture ) texture = get_textures( editor );
					if ( !texture ) return [ text_input.value, value_input.value ] = [ "", "" ];

					switch ( key ){
						case "":
							text_input.value = ""; value_input.value = ""; return;
						break;
						case "name":
						case "uuid":
							text_input.value = texture[key]; value_input.value = ""; return;
						break;
						case "rotation":
							var value = RAD2DEG*texture[key];
							text_input.value = ""; value_input.value = value.toFixed(1); return;
						break;
						default:
							var value = texture[key];
							text_input.value = ""; value_input.value = value; return;
						break;
					}

				});

				key_droplist.addEventListener( "change", function(){ 
					this.blur(); callWatchers( this, "onchange", "change", this.value ); 
				});

			})(
				materialEditor, // editor,
				TabUI.MaterialEditorTextures.tab.querySelector("input#material-editor-textures-text-input"),       // text_input,
				TabUI.MaterialEditorTextures.tab.querySelector("input#material-editor-textures-value-input"),      // value_input,
				TabUI.MaterialEditorTextures.tab.querySelector("select#material-editor-textures-key-droplist"),    // key_droplist.
				TabUI.MaterialEditorTextures.tab.querySelector("select#material-editor-textures-map-droplist")     // map_droplist.
			);

		//	material-editor-textures-vector-droplist.js

			(function(editor,vector_x,vector_y,vector_droplist,map_droplist){

				function get_textures(material){
					var textures = []; // textures.length = 0;
					var keys  = "map,aoMap,envMap,lightMap,bumpMap,alphaMap,normalMap,specularMap,";
						keys += "gradientMap,emissiveMap,metalnessMap,roughnessMap,displacementMap";
					keys.split(",").forEach(function(name){ if ( material[name] ) textures.push( material[name] ); }); 
					if ( textures.length ) return textures[0];
				}

				watch( vector_droplist, "onchange", function(prop, event, key){ 

					var texture, name = map_droplist.value;
					if ( name ) texture = editor[ name ];
					if ( !texture ) texture = get_textures( editor );

					if ( !( key && texture ) ) [ vector_x.value, vector_y.value ] = [ "", "" ];
					else [ vector_x.value, vector_y.value ] = [ texture[key].x, texture[key].y ];

				});

				vector_droplist.addEventListener( "change", function(){ 
					this.blur(); callWatchers( this, "onchange", "change", this.value ); 
				});

			})(
				materialEditor, // editor,
				TabUI.MaterialEditorTextures.tab.querySelector("input#material-editor-textures-vector-x-input"),   // vector_x,
				TabUI.MaterialEditorTextures.tab.querySelector("input#material-editor-textures-vector-y-input"),   // vector_y,
				TabUI.MaterialEditorTextures.tab.querySelector("select#material-editor-textures-vector-droplist"), // vector_droplist.
				TabUI.MaterialEditorTextures.tab.querySelector("select#material-editor-textures-map-droplist")     // map_droplist.
			);

		//	material-editor-textures-map-droplist.js

			(function(editor,text_input,value_input,vector_x,vector_y,key_droplist,vector_droplist,map_droplist){

				watch( map_droplist, "onchange", function(prop, event, value){ debugMode && console.log({item:map_droplist,event:event,value:value}); }); // debug!

				var keys = "map,aoMap,envMap,lightMap,bumpMap,alphaMap,normalMap,specularMap,gradientMap,emissiveMap,metalnessMap,roughnessMap,displacementMap";

				watch( map_droplist, "onchange", function(prop, event, value){ 

					var textures = []; var maps = keys.split(","); 
					maps.forEach(function(key){ if ( editor[key] ) textures.push( editor[key] ); }); 

					debugMode && console.log( textures );
				});

				watch( map_droplist, "onchange", function(prop, event, value){ 
					callWatchers( key_droplist, "onchange", "change", key_droplist.value ); 
					callWatchers( vector_droplist, "onchange", "change", vector_droplist.value ); 
				});

				map_droplist.addEventListener( "change", function(){ 
					this.blur(); callWatchers( this, "onchange", "change", this.value ); 
				});

				callWatchers( map_droplist, "onchange", "change", map_droplist.value );

			})(
				materialEditor, // editor,
				TabUI.MaterialEditorTextures.tab.querySelector("input#material-editor-textures-text-input"),       // text_input,
				TabUI.MaterialEditorTextures.tab.querySelector("input#material-editor-textures-value-input"),      // value_input,
				TabUI.MaterialEditorTextures.tab.querySelector("input#material-editor-textures-vector-x-input"),   // vector_x,
				TabUI.MaterialEditorTextures.tab.querySelector("input#material-editor-textures-vector-y-input"),   // vector_y,
				TabUI.MaterialEditorTextures.tab.querySelector("select#material-editor-textures-key-droplist"),    // key_droplist.
				TabUI.MaterialEditorTextures.tab.querySelector("select#material-editor-textures-vector-droplist"), // vector_droplist.
				TabUI.MaterialEditorTextures.tab.querySelector("select#material-editor-textures-map-droplist")     // map_droplist.
			);

		</script>

		<script>
/*
		//	material-editor-textures-viewer-center.js

			(function( editor,viewer,entity_droplist,vector_x,vector_y,vector_droplist,map_droplist ){

				var texture = new THREE.Texture(); 

				function get_texture( name ){
					var maps  = "map,aoMap,envMap,lightMap,bumpMap,alphaMap,normalMap,specularMap,";
						maps += "gradientMap,emissiveMap,metalnessMap,roughnessMap,displacementMap";
					var textures = maps.split(",").map(function(name){ return material[name]; }).filter(Boolean);
					if ( !textures.length ) return texture = undefined;
					if ( name && editor[ name ] ) texture = editor[ name ];
					else if ( textures.length ) texture = textures[0];
					else return texture = undefined; 
				}

				watch( map_droplist,    "onchange", function(prop, event, value){ get_texture(map_droplist.value); });
				watch( vector_droplist, "onchange", function(prop, event, value){ get_texture(map_droplist.value); });
				watch( entity_droplist, "onchange", function(prop, event, value){ get_texture(map_droplist.value); });

			})( 
				materialEditor, materialEditorViewer, // editor, viewer,
				TabUI.Material.tab.querySelector("select#material-entities-droplist"), // (material) entity_droplist.
				TabUI.MaterialEditorTextures.tab.querySelector("input#material-editor-textures-vector-x-input"),   // vector_x,
				TabUI.MaterialEditorTextures.tab.querySelector("input#material-editor-textures-vector-y-input"),   // vector_y,
				TabUI.MaterialEditorTextures.tab.querySelector("select#material-editor-textures-vector-droplist"), // vector_droplist.
				TabUI.MaterialEditorTextures.tab.querySelector("select#material-editor-textures-map-droplist")     // map_droplist.
			);
*/

		</script>

		<script>

			TabUI.MaterialEditorTextures.role.classList.add("active");
			TabUI.MaterialEditorTextures.tab.classList.add("in","active");
			TabUI.MaterialEditorTextures.pill.scrollIntoViewIfNeeded(false);

		//	scene.add(ground);
		//	mirror.visible = !mirror.visible; 
		//	ground.visible = !ground.visible; 
			groundHelper.visible = !groundHelper.visible; 


		//	Add entities.
		//	entities.add(scene);
		//	entities.add(mirror);
		//	entities.add(ground);
		//	entities.add(localPlayer);
			entities.add(groundHelper);
			entities.add(localPlayer.getObjectByName("local helper"));

			cameraControls.setLatLon(5.128, 270.675);
			localPlayer.controller.movementSpeed = 20;
			localPlayer.controller.center.set(-85,2,-2);
			localPlayer.visible = !localPlayer.visible; 

		</script>

		<script src="/editor/src/database-tab-ui.js"></script>
		<script src="/editor/src/database-inputs.js"></script>
	<!-- script src="/editor/src/ViewportTab.js"></script -->
		<script src="/editor/src/playground.js"></script>

	</body>
</html>
